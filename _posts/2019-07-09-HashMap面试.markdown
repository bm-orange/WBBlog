---
layout: post
title: 'HashMap面试'
date: 2019-07-09 09:12
categories: Java
---

HashMap在我面试的过程中已经被问了很多遍了，之前一直是看博客，稍稍看了下源码，但是每次回答我都不满意，因此痛下决心分析了源码，发现这个类的实现是真的复杂，因此也并没有完全吃透源码，现将学习到的做一个记录。

HashMap是一个通过hash表的方式实现的Map结构，内部采用了链表+红黑树的方式来解决冲突。它与Hashtable的功能类似，不过它不是同步的即线程安全，同时它允许key与value都可以为null。它的基本操作get和put都是常量级的时间复杂度。

## 性能

HashMap的性能与`capacity`和`load factor`相关，容量是其内部的hash表的长度，负载因子是hash表允许满的程度。容量太大浪费空间，太小冲突频繁影响性能，而负载因子太小也浪费空间，太大冲突频繁，查找性能下降。官方缺省使用0.75作为负载因子。整个hashmap使用了动态扩容的技术，缺省初始容量为16，也可以构造时指定。每次扩容会进行`rehash`操作，消耗性能，因此在已知预期条目数量的情况下可以初始时指定足够大的容量，减少扩容操作。HashMap的容量被保证是2的幂，每次扩容将增加一倍，这个在扩容部分再细说。

## hash函数

HashMap使用的key值的hash值是通过`hash`方法从新计算的，假设key的hash值为`hashcode`，那么HashMap使用`hashcode`与它的高16位异或的操作计算得出hash值，即`hash = hashcode ^ (hashcode >>> 16)`，使用这样的hash函数的原因，源码中的描述我没搞懂，我自己的理解是，每次确定一个key在hash表中的位置时，使用的是它的hash值的低几位，在仅使用低几位的情况下，高位部分将变的没用，本身分布较均匀的hash值的位置集中由低几位确定，冲突集中，因此通过将高位与低位异或，将高位冲突向下合并，使整个位置由高位和低位同时确定。

## `tableSizeFor(int cap)`计算与cap最接近的2的幂的数

当我们来处理这个问题时，就是找到cap二进制表示中最高位的1的位置，假设做高位1的位置为n，那么这个最接近的2的幂要么是`2^(n-1)`，要么是`2^n`.现在来看以下源码中魔幻的算法

```java
static final int tableSizeFor(int cap) {
        int n = cap - 1;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    }
```

其中

```java
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        /*
        假设n的最高位为1的位置为d
        则n = 0b0000...1...0101...
        当右移1位后，与原值相或，d位与d-1位都为1，
        而当再变化后的值右移2位，保证了d位与d-1位与d-2和d-3位都是1
        以此类推当变化到最后时，d位之后的值都变为了1
        
        而最初的n= cap-1，分两种情况讨论
        1.若cap刚好为2的幂，设cap = 2^k
        那么cap-1之后，n的低k位都为1，经过后面的运算n仍等于n，
        在加1之后得到本身为2的幂的cap
        2.若cap不为2的幂，那么cap除了最高位的1之外(设最高的1位在d处)，其后还存在为1的位，
        在减1之后不影响cap的最高位为1的位置，通过后边的运算，
        将n除了最高为1的位之后的所有位都变为了1，即d之后的所有位都为1，
        在经过n+1运算后，变化为d+1位为1其余位为0，正好是要找的最接近的2的幂的数。
        */
```

与Integer中找整数的最高位的1的方法是一致的。

## resize

扩容，在HashMap的size大于阈值`threshold = capacity * load factor`的时候将进行扩容操作，同时HashMap的hash表开始并没有初始化，在使用时通过resize操作进行初始化。

**为什么HashMap的容量总是2的幂？**

初始时，根据HashMap的构造函数，有两种情况:

1. 使用HashMap()构造函数，初始的容量和阈值都为0，根据resize的操作，将设定新的容量为缺省的初始容量16，新阈值为容量与负载因子的乘积。
2. 使用HashMap(int capacity)等构造函数，初始的容量为0，初始的阈值为根据容量确定的一个2的幂的数cap，新的容量被设定为旧阈值cap，新阈值还是容量与负载因子的乘积。

通过上面的分析，明确最初时hash表的容量一定是2的幂，而每次扩容都扩充为原来容量的一倍，因此新容量还是2的幂，这保证了HashMap的容量总是2的幂。

**为什么HashMap的容量使用2的幂？**

原因我不太清楚，但是阅读源码后发现，使用2的幂作为容量，使得扩容后，原来key在旧表中的位置为idx，则在新表中key的位置要么为idx，要么偏移一个旧表的容量为idx+oldcap。

假设旧表容量为`oldcap = 64 = 2^6`,则新表容量为`newcap = 128 = 2^7`,将它们转为二进制后：

**旧表**

`oldcap = 0b100 0000`

**新表**

`newcap = 0b1000 0000`

即，若容量为`2^n`，那么它的二进制的第`n+1`位为`1`，其余为`0`

而在确定key的位置时，假设key的hash值用`hash`表示，则它在表中的索引`idx = (cap - 1) & hash`继续上面的例子

**旧表中的索引idxO**

`idxO = hash & 0b11 1111`

**新表中的索引idxN**

`idxN = hash & 0b111 1111`

可以发现，若容量`cap = 2^n`，那么`cap-1 = 0b111..111`低n位都为1，其余为零，所以在取地址时，其实就是使用hash值的低n上的值作为索引。因此假如原来使用低n位作为位置，在新表后就使用低n+1位，所以新的位置，只需看hash值的第n+1位为1还是0，若为0则新位置与原位置一样，若为1则新位置偏移一个量（`idxN = idxO | 0b100...00`二进制长度为n+1，刚好这个值为旧表容量，也即`idxN = idxO + oldcap`）.

## get过程

* 计算key对应的hash值`hash = key.hashCode() ^ (key.hashCode() >>> 16)`
* 根据hash值确定索引的位置`idx = (cap-1) & hash`
* 若该位置为null，返回null
* 否则，判断首元素是否就是要找的key`(e.hash == hash) && (e.key == key || (key != null && key.equals(e.key)))`
* 如果首元素不是，并且首元素next不为null，如果是树节点，则在树中查找，否则以链表的方式查找
* 找到返回node，否则返回null

## put过程

* 计算key的hash值
* 如果hash表为null，resize创建初始的hash表
* 计算地址，查看该位置是否为null
* 若为null，创建新节点插入
* 否则判断首节点是否是查找的节点，如果是保存该节点
* 否则，判断是树节点还是链表节点，若是树节点，向树节点中插入，保存返回节点
* 若是链表节点，查找同时在查找过程中计算链表的长度，如果找到保存该节点，否则在最后一个节点之后插入新节点，同时判断链表长度是否大于树化阈值，若大于则将链表树化
* 如果保存的节点不为null，那么根据情况替换为新值，并且调用hook方法
* 否则hashmap的改变次数自增1，同时size自增1，并判断是否大过阈值，大过则进行resize扩容操作，同时调用hook方法

**注：**`afterNodeAccess(Node<K,V> p), afterNodeInsertion(boolean evict), afterNodeRemoval(Node<K,V> p)`三个hook方法，是LinkedHashMap中用来保证在维护插入顺序，和维持一个以最近访问顺序为为序的链表，用于实现LRU算法。

## 其他细节

HashMap实现中设置了许多常量，这里说部分常量的意义

**树化阈值`TREEIFY_THRESHOLD = 8`**

当解决冲突的链表的长度超过8时，进行将链表转为红黑树的操作，为什么设置为8，在源码中找到一个说明，当hash值随机分布时，链表中的长度服从泊松分布，当长度为8时，概率为`0.00000006`，当链表长度更大时，概率小于千万分之1，所以当把树化阈值设置为8时，查找链表的操作还不费时，同时需要转换为红黑树结构的概率非常小，因此红黑树结构在hashmap出出现的频率其实不高。

**非树化阈值`UNTREEIFY_THRESHOLD = 6`**

当红黑树的节点小于6时，需要将红黑树转变为链表结构。

**树化的最小阈值`MIN_TREEIFY_CAPACITY = 64`**

只有当容量大于64时，链表长度超过8才进行转红黑树的操作，否则将hash表扩容`resize`

## 参考

[Integer位操作技巧解析](https://blog.csdn.net/mccxj/article/details/55799306)<br>
[Hacker's Delight](https://book.douban.com/subject/25837031/)<br>
