---
layout: post
title: '类加载、链接与初始化(Loading, Linking, and Initializing)'
date: 2019-07-07 10:08
categories: Java
---
**翻译Java虚拟机规范**

Java虚拟机动态加载、链接和初始化类与接口。**加载过程:**通过一个特定的名字查找一个类或接口的字节表示然后从字节表示中创建类或接口。**链接过程:**获得类或接口，将其合并到Java虚拟机的运行时状态，使其可以执行。**初始化：**包括执行类或接口的初始化方法`<cinit>`。

## 运行时常量池

这是一种运行时数据结构，与传统编程语言的符号表有许多相同的用途，运行时常量池中维护了每个类型的常量池。

类或接口的字节文件中的`constant_pool`表在类或接口创建时被表示成为Java虚拟机中的运行时常量池。在运行时常量池中的所有应用最初都是符号表示。这些符号引用从类或接口的字节文件中派生出来。

## Java虚拟机的启动

Java虚拟机通过使用`bootstrap`类加载器创建一个初始化类，然后Java虚拟机链接初始化类，初始化初始化类，然后调用`public`的类方法`void main(String[])`完成启动。`main`方法的执行可能导致其他类或接口的链接，也可能调用其他的方法。

### 创建并加载

用名字`N`表示的类或接口`C`的创建为在Java虚拟机的方法区中构造特定于该类的内部表示。类或接口`C`的创建可以被另外的类或接口`D`触发，`D`在它的运行时常量池中引用了`C`。`C`的创建也可以通过`D`调用某些平台类库中的方法(如反射)来触发。

如果`C`不是一个数组类，它通过一个类加载器加载它的字节文件而创建。数组类没有外部字节文件，它们通过Java虚拟机创建而不是类加载器。

有两种类加载器：由Java虚拟机提供的`bootstrap class loader`和用户定义的类加载器。用户定义的类加载器是抽象类`CLassLoader`的子类的一个实例。应用使用用户定义的类加载器以扩展Java虚拟机动态加载的方式，从而创建类，自定义类加载器可以从自定义的源中创建类。如，一个类可以通过网络下载、动态生成或是从加密文件中提取。

类加载器`L`可以直接定义类`C`，或者将其委托给其他类加载器完成(**双亲委派**)。如果`L`直接创建了`C`，我们称`L`定义了`C`，或者`L`是`C`的定义类加载器。

当一个类加载器委托另一个类加载器时，启动的类加载器并不一定是最终完成类的定义的加载器。如果`L`创建`C`，要么直接定义，要么通过委托，我们都说`L`初始化了`C`的加载，或者`L`是`C`的初始化类加载器。

在运行时，一个类或接口是通过它的限定名和它的定义类加载器唯一确定的。每个类或接口都属于单个运行时包`run-time package`。运行时包由包名和类或接口的定义类加载器确定。

Java虚拟机通过如下三个过程之一来创建由名字`N`表示的类或接口`C`：

+ 如果`N`表示的是一个非数组类或接口，下面两个方法之一将加载并创建`C`

   + 如果`D`由启动类加载器定义，那么启动类加载器初始化`C`的加载。
   + 如果`D`由用户类加载器定义，那么相同的用户类加载器将初始化`C`的加载。

+ 一个数组类的创建直接由Java虚拟机完成，而不通过类加载器，但是在创建数组类`C`的过程中使用了`D`的定义类加载器。

#### 使用Bootstrap类加载器加载

使用启动类加载器加载由名字`N`表示的类或接口时步骤如下。

+ 首先，Java虚拟机确定启动类加载器是否已经被记录为`N`表示的类或接口的初始类加载器。如果是，类或接口就是`C`，不需要创建类。
+ 否则，Java虚拟机将`N`传递给启动类加载器的方法调用，搜索`C`的字节表示。典型的，类或接口被表示为一个层级文件系统中的一个文件，类或文件的名字被编码为表示文件的路径名。
+ 然后Java虚拟机尝试通过启动类加载器从表示文件中创建类。

#### 使用自定义类加载器加载

自定义类加载器`L`加载`N`表示的类`C`的过程为。

 Java虚拟机确定是否`L`已经记录为`N`表示的类或接口的初始类加载器，如果是那么不需要创建类。
 
 否则，Java虚拟机在`L`上调用`loadClass(N)`。调用返回值就是创建的类或接口`C`。Java虚拟机记录`L`是`C`的初始化加载器。详细过程为。
 
 当`L`的`loadClass`方法被调用时，名字`N`表示的类`C`将被加载，`L`必须执行一下两种操作之一才能加载`C`：
 
 1. 类加载器`L`可能创建一个字节数组以`ClassFile`的字节结构表示`C`；然后它必须调用`ClassLoader`的`defineClass`方法。`defineClass`方法将使Java虚拟机从字节数组中派生处类或接口。
 2. 类加载器`L`能委托`C`的加载给其他类加载器`L'`。通过直接或间接的将名字`N`传递给`L'`实现，调用结果就是`C`。

#### 创建数组类

如果`L`已经被记录在`N`表示的数组类的相同组件类型的初始化类加载器中，不需要创建数组类。

否则，使用下面的步骤创建`C`：

1. 如果数组的组建类型是一个`reference`类型，使用`L`加载并创建组件类型`C`。
2. Java虚拟机使用指定的组件类型和维数创建一个新的数组类。如果组件类型是引用类型，`C`被标记为由组件类型的定义类加载器定义，否则`C`被标记由启动类加载器定义。

### 加载约束

当一个类或接口`C  = <N1, L1>`作为另一个类或接口`D = <N2, L2>`的字段或方法的符号引用时，符号引用包括指定字段类型、方法返回类型和参数类型的描述符。在字段或方法描述符中提及的任何类型名`N`通过`L1`加载和`L2`加载表示相同的类或接口，这非常重要。

为了保证这一点，Java虚拟机在准备和解析阶段增加了形如`NL1 = NL2`的加载约束。为了加强这些约束，Java虚拟机在特定的时间记录特定类加载器是特定类的初始类加载器。在记录了加载器是类的初始加载器后，Java虚拟机必须立即检查是否违反了任何加载约束。如果违反，记录将被恢复，Java虚拟机将抛出一个`LinkageError`，导致记录发生的加载操作将失败。

同时，在施加加载约束后，Java虚拟机必须立即检查是否违反了加载约束。如果违反，Java虚拟机收回新施加的加载约束，同时抛出`LinkageError`，导致施加约束的操作将失败。

### 从`class`文件表示中派生类

从类文件中派生出`N`表示的非数组类或接口`C`的`Class`对象的过程为：

1. 首先，Java虚拟机确定是否`L`已经被记录为类的初始化加载器，如果是，创建尝试将无效，并且加载抛出`LinkageError`。
2. 否则，Java虚拟机将尝试解析字节表示。然而这个表示可能实际上不是`C`的有效表示。
3. 如果`C`有一个直接父类，那么从`C`到它直接父类的符号引用将被解析。如果`C`是一个接口，它必须有`Object`作为它的直接父类，且必须已经被加载。只有`Object`没有直接父类。
4. 如果`C`有任何直接父接口，从`C`到父接口的符号引用将被解析。
5. Java虚拟机标记`C`拥有定义类加载器`L`，并且记录`L`是`C`的初始类加载器。

## 链接

链接一个类或接口涉及到验证和准备这个类或接口，以及它的父类、父接口和它的元素类型(如果这是一个数组类型)。在类或接口中的符号引用的解析是链接的一个可选部分。

规范允许灵活的实现链接，但是需要保证:

+ 一个类或接口在它被链接之前已经被加载。
+ 类或接口需要在初始化开始之前完成验证和准备。
+ 在链接期间出现的错误，将被程序中的某个点抛出，在程序执行的一些操作可能直接或间接的需要链接到错误发生的相关类或接口。

### 验证`Verification`

验证保证类或接口的二进制表示是结构正确的。验证可能造成其他类和接口被加载但是不造成它们的验证和准备。

### 准备`Preparation`

`preparation`涉及创建类或接口的静态字段并初始化这些字段为它们的缺省值。这不需要执行任何Java虚拟机代码；准确的初始化静态字段在初始化阶段执行，而不是准备阶段。

在类或接口`C`的准备阶段，Java虚拟机也添加加载约束。设`L1`是`C`的定义类加载器。对于`C`中的每个方法`m`，这些方法重写了声明在父类或父接口`<D, L2>`中的方法，Java虚拟机添加这些加载约束:

设`m`的返回类型是`Tr`，形参类型是`Tf1,Tf2,...,Tfn`，那么：

如果`Tr`不是数组类型，那么`T0`是`Tr`，否则`T0`是`Tr`的元素类型。

对于`i = 1 to n`，如果`Tfi`不是一个数组类型，那么`Ti = Tfi`，否则`Ti`就是`Tfi`的元素类型。

然后对于所有的`i = 0 to n`，都有`Ti^L1 = Ti^L2`。

准备可以在创建之后任何时间进行，但是必须在初始化之前完成。

### 解析`Resolution`

Java虚拟机指令`anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, putstatic`对运行时常量池进行符号引用。这些指令中的任何一个执行时都需要解析它的符号引用。

解析是动态的确定运行时常量池中符号引用的具体值的过程。

在接口或类`D`的运行时常量池中解析符号引用的过程，会因符号引用的不同类型而有所不同。

#### 类或接口型符号引用解析

为了解析`D`中到一个类或接口`C`(由`N`表示)的符号引用，下面的步骤将被执行:

1. `D`的定义类加载器被用来创建名称为`N`的类或接口，创建的类或接口是`C`。
2. 如果`C`是一个数组，并且它的元素类型是一个引用类型，代表元素类型的类或接口的符号引用将被递归的解析。
3. 最后，检查`C`的访问权限。

#### 字段解析

#### 方法解析

#### 接口方法解析

#### 方法类型和方法句柄解析

#### 调用点说明符解析(`Call Site Specifier Resolution`)

### 访问控制

一个类或接口`C`能够被类或接口`D`访问，当且仅当:

+ `C`是`public`
+ `C`和`D`是相同运行时包的成员。

字段或方法`R`能够被类或接口`D`访问仅当:

+ `R`是`public`
+ `R`是`protected`并且在`C`中声明，`D`要么是`C`本身或者为`C`的子类。另外，如果`R`不是静态的，到`R`的符号引用必须包含到类`T`的符号引用，`T`为`D`的子类、父类或其本身。???
+ `R`是`protected`或是缺省的访问权限，并且`R`被声明在一个类中，该类与`D`有相同的运行时包。
+ `R`是`private`并且声明在`D`中。

### 重写

## 初始化

类或接口的初始化包括执行它的初始化方法。

类或接口`C`在以下情形会被初始化:

+ Java虚拟机的`new, getstatic, putstatic, invokestatic`中的任何一个执行，引用`C`将被初始化。这些指令或者直接或者间接引用一个类，通过字段引用或方法引用。

`new`指令的执行，引用的类如果未初始化，则初始化。

`getstatic, putstatic, invokestatic`指令执行，类或接口声明的已解析的字段或方法尚未初始化。

+ 首次调用`java.lang.invoke.MethodHandle`实例 ???
+ 在类库中确定的反射方法的调用，如在类`Class`或在包`java.lang.reflect`。
+ 如果`C`的子类之一初始化。
+ 如果`C`是一个接口，声明了非抽象，非静态的方法，它的直接或间接实现类的初始化。
+ 如果类`C`，被指定为Java虚拟机启动时的初始类。

在初始化之前，类或接口必须被链接，即验证、准备和可选的解析。

由于Java虚拟机是多线程的，初始化一个类或接口时需要小心同步，因为可能会有其他线程尝试初始化相同的类在同一时刻。同时可能递归的请求初始化这个类作为类初始化的一部分。Java虚拟机通过下面的过程保证同步和递归的初始化类。假定类对象已经被验证和准备，类对象有如下四种状态中的一种：

1. 类对象已经被验证和准备但是还没有初始化。
2. 类对象正在由某个特定线程初始化。
3. 类对象已经完成初始化，可以被使用。
4. 类对象处于错误状态，可能是因为初始化失败。 

对于每个类`C`，存在一个初始化锁`LC`。从`C`到`LC`的映射由虚拟机实现决定。`C`的初始化过程如下:

1. 在初始化锁`LC`上同步。当前线程等待直到获得锁`LC`。
2. 如果`C`的类对象表明其他线程正在对它进行初始化，那么释放锁，并且当前线程阻塞，直到通知正在进行的初始化已经完成，然后重复此过程。
3. 如果`C`的类对象指明当前线程正在对它进行初始化，那这必然是初始化的一个递归请求。释放锁并且正常完成。
4. 如果类对象指明`C`已经被初始化，并且没有更多操作被要求，那么释放锁，正常完成。
5. 如果类对象处于错误状态，那么初始化不可能完成，释放锁并且抛出`NoClassDefFoundError`。
6. 否则，记录类对象`C`正在当前线程初始化的事实，然后释放锁。然后初始化每个`final static`字段使用`C`的`ConstantValue`属性中的常量值。
7. 如果`C`是一个类而不是接口，它的父类还没有初始化，设它的父类为`SC`，而`Sl1, ..., Sln`是它的父接口(直接或间接的)，这些接口至少声明了一个非抽象，非静态的方法。对于在列表`[SC, Sl1, ..., Sln]`中的每个`S`递归的执行这整个过程，如果需要，首先验证和准备`S`。
8. 接着，查询`C`的定义类加载器，类是否启用了断言。
9. 执行`C`的初始化方法。
10. 如果类的初始化方法的执行正常完成，那么请求锁`LC`，标记`C`的类对象的状态为完全初始化，并通知所有等待的线程，释放锁，正常完成这个过程。
11. 否则，类的初始化方法必须通过抛出某个异常`E`而突然完成。
12. 请求锁，标记类对象为错误状态，通知所有等待的线程，同时释放锁。突然完成此过程，并按上一步执行。

## 绑定Native方法实现

`Binding`是将Java语言以外的语言编写的函数和实现的`native`方法集成到Java虚拟机中以便执行的过程。尽管这个过程在传统上被称为链接，规范使用绑定，以避免与Java虚拟机中的类或接口的链接混淆。

## 参考
[Chapter 5. Loading, Linking, and Initializing](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html)<br>
